% Created 2018-06-21 Thu 12:30
\documentclass[8pt]{beamer}
\usepackage[sc,osf]{mathpazo}   % With old-style figures and real smallcaps.
\linespread{1.025}              % Palatino leads a little more leading
% Euler for math and numbers
\usepackage[euler-digits,small]{eulervm}
%\documentclass[10pt]{llncs}
%\usepackage{llncsdoc}
\usepackage{hyperref}
\usepackage{minted}
\usemintedstyle{xcode}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{polynom}

\hypersetup{colorlinks=true,
    linkcolor = blue,
    urlcolor  = blue,
    citecolor = blue,
    anchorcolor = blue
}
\renewcommand{\mod}[1]{\left( \texttt{mod}~#1 \right)}
\newcommand{\N}{\mathbb N}
\newcommand{\B}{\mathbb B}
\newcommand{\Z}{\mathbb Z}
\newcommand{\Q}{\mathbb Q}
\newcommand{\C}{\mathbb C}
\newcommand{\degree}{\texttt{degree}}
\newcommand{\cpp}[1]{\mintinline{cpp}{#1}}
\newcommand{\py}[1]{\mintinline{py}{#1}}
\newcommand{\raw}[1]{\mintinline{text}{#1}}
\newcommand{\hs}[1]{\mintinline{hs}{#1}}
\tolerance=1000
\usetheme{Antibes}
% \usetheme{Warsaw}
\author{Siddharth Bhat}
\date{October 18th, 2019}
\institute{IIIT Open Source Developers group}
\title{A taste of Haskell?}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.5.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle

\begin{frame}[fragile]{What's programming like?}
    A lot like building a cathedral.
\end{frame}

\begin{frame}[fragile]{Why we pray}
\pause

{\small
\begin{minted}{cpp}
#include <iostream>
#include <climits>
using namespace std;

// f(x) == true ?
bool f(unsigned x) { return (x + 1) > x; }

int main() {
    cout << "f(0): " << f(0) << "\n";
}
\end{minted}
\pause
\begin{minted}{raw}
f(0): 1
\end{minted}
\pause
\begin{itemize}
    \item 
        $f: \N \rightarrow \B; f(x) \equiv \begin{cases} \texttt{true} & x + 1 > x \\ \texttt{false} & \text{otherwise} \end{cases}$
        \pause
    \item $f(x) \equiv \texttt{true}$ \pause
\end{itemize}
Always going to return \cpp{true}?
\pause
\begin{minted}{cpp}
int main() {
    cout << "f(UINT32_MAX): " << f(UINT32_MAX) << "\n";
}
\end{minted}
}

\pause
\begin{minted}{text}
f(UINT32_MAX):0
\end{minted}

\pause
\begin{itemize}
    \item $f: \N \rightarrow \B; f(x) \equiv \begin{cases} \texttt{true} & x +_{2^{32}} 1 > x \\ \texttt{false} & \text{otherwise} \end{cases}$ \pause
    \item $+_{2^32}: \N \times \N \rightarrow \N; x +_{2^{32}} y \equiv (x +_\N y) \% 2^{32}$ \pause; $\texttt{UINT32\_MAX} +_{2^{32}} 1 = 0 $
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Why we pray: A second example}
\pause
$$ \forall x \in \Z, 2 * x = x + x$$
\pause
(Also holds in modular arithmetic)
\pause
\begin{minted}{cpp}
int main() {
  cout << 2 * ((int) getchar()) << "\n";
}
\end{minted}
\pause

\begin{minted}{cpp}
int main() {
  cout << ((int)getchar() + (int)getchar()) << "\n";
}
\end{minted}

\pause


\begin{itemize}
    \item \cpp{int getchar()} \pause
    \item $\texttt{getchar}: \emptyset \rightarrow \texttt{int}$ \pause
    \item $\{ \} \rightarrow \{ 1, 42, \dots \}$ \pause
    \item Such a function can't return an output! \pause
    \item $\texttt{getchar}: \{ \star \} \rightarrow \texttt{int}$ \pause
    \item $\{ \star \} \rightarrow \{ 1, 42, \dots \}$ \pause
    \item $\{ \star \} \rightarrow \{ 1, 42, \dots \}~ \star \mapsto 42$ \pause
    \item Such a function will always return the same output! \pause
    \item \texttt{getchar} can't be a mathematical function.
\end{itemize}

\pause

\end{frame}

\begin{frame}[fragile]{Why we pray: A third example}
\begin{minted}{cpp}
int K (int x, int y) { return x; } // K(x, y) = x
\end{minted}
\pause
\begin{minted}{cpp}
int main() { cout << K(10, 20) << "\n" cout << 10; }
\end{minted}
\pause
\cpp{K(10, 20)} $=  10$
\pause
\begin{minted}{cpp}
int err() { exit(1); return 0; } // start praying!
int main() { cout << K(10, err()) << "\n" cout << 10; }
\end{minted}
\pause
\cpp{K(10, err())} $\neq 10$
\pause

\begin{itemize}
    \item Mathematically, can replace $K(x, y)$ by $x$. \pause
    \item In C(++), impossible. \pause
    \item cannot \textbf{equationally reason} about programs. \pause
    \item \textbf{Can we} reason about programs? \pause
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Can we reason about C++?}
    \pause
    \begin{itemize}
    \item Short answer: Yes. \pause
    \item Longer answer: Yes. It's complicated. \pause
    \item Name dropping: Operational/Denotational semantics. \pause
    \item Name dropping: Hoare logic/Separation logic. \pause
    \end{itemize}
\end{frame}


\begin{frame}[fragile]{How do we escape having to pray?}
    \pause
    Define a language, \pause where anything that happens, \pause is what \textbf{mathematics} says should happen.
    \pause

\end{frame}

\begin{frame}[fragile]{A taste of Haskell}
    \begin{itemize}
        \item \hs{let xs = [1, 2,..10]} \pause
        \item \py{xs = range(10)} \pause
        \item \hs{let nats = [1, 2..]} \pause
        \item \py{xs = ??} \pause
        \item \hs{take 2 nats} \pause
        \item \hs{take 10 nats} \pause
        \item \hs{take 100 nats} \pause
        \item Haskell is \emph{lazily evaluated} \pause
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Why laziness?}
\begin{itemize}
\item \raw{:t "foo"} \pause
\item \hs{"foo" :: [Char]}
\item \hs{take 2 "foo"} \pause
\item \raw{:t take}
\item \hs{take :: Int -> [a] -> [a]} \pause
\item $\texttt{take} :: \forall (\alpha \in \texttt{TYPE}), \texttt{Int} \rightarrow \texttt{List}(\alpha) \rightarrow \texttt{List}(\alpha)$\pause
\item \hs{take 1 'a'} \pause
\item
\begin{minted}{text}
Prelude> take 1 'a'

<interactive>:11:8: error:
    • Couldn't match expected type ‘[a]’ with actual type ‘Char’
    • In the second argument of ‘take’, namely ‘'a'’
      In the expression: take 1 'a'
      In an equation for ‘it’: it = take 1 'a'
    • Relevant bindings include it :: [a] (bound at <interactive>:11:1)
\end{minted}
\pause
\item If $f: A \rightarrow B$, \pause can ask $f(a)$ for $a \in A$.
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Philosophical differences}

\pause

\begin{columns}% [T] % align columns
\begin{column}{.48\textwidth}
\begin{minted}{py}
" ".join(["a", "b", "c", "d"])
\end{minted}
\pause
\begin{minted}{text}
str.join(iterable)
\end{minted}

Return a string which is the concatenation of the strings in \emph{iterable}. A
\verb|TypeError| will be raised if there are any non-string values in \emph{iterable},
including \verb|bytes objects|. The separator between elements is the string providing
this method.


\end{column}
%
\begin{column}{.48\textwidth}
\pause
\begin{minted}{hs}
intercalate " " ["a", "b", "c", "d"]
\end{minted}

\pause
\begin{minted}{hs}
intercalate :: 
  String -> [String] -> String
\end{minted}

\pause
\verb|intercalate xs xss| is \emph{equivalent} to \verb|(concat (intersperse xs xss))|.
It inserts the list \verb|xs| in between the lists in \verb|xss| and concatenates the result.

\pause

\begin{minted}{hs}
intercalate :: 
  [Char] -> [[Char]] -> [Char]
intercalate :: [a] -> [[a]] -> [a]
\end{minted}
\pause

\begin{minted}{hs}
intercalate [1, 2] 
  [[3,4], [30, 40], [300, 400]]
\end{minted}
\pause
\begin{minted}{hs}
= [3, 4, 1, 2, 30, 40, 1, 2, 300, 400]
\end{minted}

\end{column}
\end{columns}

\pause
{\tiny \url{docs.python.org/3/library/stdtypes.html#str.join}}
{\tiny \url{hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html#v:intercalate}}
\end{frame}


\begin{frame}[fragile]{Summing over a list of numbers}


\begin{columns}% [T] % align columns
\begin{column}{.48\textwidth}
\begin{minted}{py}
sum([1, 2, 3, 4])
\end{minted}
\pause
\begin{minted}{text}
sum(iterable, /, start=0)
\end{minted}

Sums \emph{start} and the items of an \emph{iterable} from left to right and
returns the total. The \emph{iterable}’s items are normally numbers, and the start
value is not allowed to be a string.

\pause

\end{column}
%
\begin{column}{.48\textwidth}
\begin{minted}{hs}
sum [1, 2, 3, 4]
\end{minted}

\pause
\begin{minted}{hs}
sum :: (Foldable t, Num a) => t a -> a
sum :: [Int] -> Int]
\end{minted}
\pause
The \verb|sum| function computes the sum of the numbers of a structure.

\end{column}
\end{columns}

\pause
\begin{itemize}
    \item \hs{sum [1, 2, 3]} \pause
    \item \hs{sum [1.1, 2.1, -3.2]} \pause
    \item \hs{let minus_1_by_12 = sum [1, 2..]}
\end{itemize}

\pause

{\tiny \url{https://docs.python.org/3/library/functions.html#sum}}
{\tiny \url{hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html#v:intercalate}}

\end{frame}


\begin{frame}[fragile]{\texttt{Num}?}
\hs{sum :: (Foldable t, Num a) => t a -> a}

\pause
\begin{minted}{hs}
class  Num a  where -- Typeclass: `a` is a Num if...
\end{minted}
\pause
\begin{minted}{hs}
    (+), (-), (*)       :: a -> a -> a
\end{minted}
\pause
\begin{minted}{hs}
    -- | Unary negation.
    negate              :: a -> a
    -- | Absolute value.
    abs                 :: a -> a
\end{minted}
\pause
\begin{minted}{py}
    -- | Sign of a number.
    -- The functions 'abs' and 'signum' should satisfy the law:
    --
    -- > abs x * signum x == x
    --
    -- For real numbers, the 'signum' is either `-1` (negative), `0` (zero)
    -- or `1` (positive).
    ...
\end{minted}

\pause
\begin{itemize}
    \item Associativity of \raw{+} \raw{(x + y) + z = x + (y + z)} \pause
    \item Commutativity of \raw{+}: \raw{x + y = y + x} \pause
    \item \raw{negate} gives the additive inverse: \raw{x + negate x = fromInteger 0} \pause
\end{itemize}

\pause
\url{https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#t:Num}

\end{frame}

\begin{frame}[fragile]{\texttt{Foldable}?}
\hs{sum :: (Foldable t, Num a) => t a -> a}

\pause
An object one can "fold over" / "accumulate answers on". \pause A list, a set, a binary tree, \dots

\begin{itemize}
    \item \hs{let x = Data.Set.fromList [1, 2, 3]} \pause
    \item \hs{fromList [1,2,3]} \pause
    \item \hs{let y = union x x} \pause
    \item \raw{fromList [1,2,3]} \pause
    \item \hs{sum y}
    \item \raw{6}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{\texttt{Foldable} in detail}

\hs{sum :: (Foldable t, Num a) => t a -> a}
\pause


\begin{minted}{hs}
class Foldable t where -- a data structure t is foldable if...
  -- | Map each element of the structure to a monoid, and combine the results.
  foldMap :: Monoid m => (a -> m) -> t a -> m
\end{minted}

\verb|Foldable| instances are expected to satisfy the following laws:

\begin{minted}{hs}
foldr f z t = appEndo (foldMap (Endo . f) t ) z
foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
fold = foldMap id
length = getSum . foldMap (Sum . const  1)
\end{minted}
{\tiny \url{https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Foldable.html#t:Foldable}}
\end{frame}

\end{document}
